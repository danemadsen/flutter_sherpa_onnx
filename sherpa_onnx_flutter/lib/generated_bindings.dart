// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
import 'dart:ffi' as ffi;

class NativeLibrary {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  NativeLibrary(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  NativeLibrary.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  /// @param config  Config for the recognizer.
  /// @return Return a pointer to the recognizer. The user has to invoke
  ffi.Pointer<SherpaOnnxOnlineRecognizer> CreateOnlineRecognizer(
    ffi.Pointer<SherpaOnnxOnlineRecognizerConfig> config,
  ) {
    return _CreateOnlineRecognizer(
      config,
    );
  }

  late final _CreateOnlineRecognizerPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<SherpaOnnxOnlineRecognizer> Function(
                  ffi.Pointer<SherpaOnnxOnlineRecognizerConfig>)>>(
      'CreateOnlineRecognizer');
  late final _CreateOnlineRecognizer = _CreateOnlineRecognizerPtr.asFunction<
      ffi.Pointer<SherpaOnnxOnlineRecognizer> Function(
          ffi.Pointer<SherpaOnnxOnlineRecognizerConfig>)>();

  /// Free a pointer returned by CreateOnlineRecognizer()
  ///
  /// @param p A pointer returned by CreateOnlineRecognizer()
  void DestroyOnlineRecognizer(
    ffi.Pointer<SherpaOnnxOnlineRecognizer> recognizer,
  ) {
    return _DestroyOnlineRecognizer(
      recognizer,
    );
  }

  late final _DestroyOnlineRecognizerPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<SherpaOnnxOnlineRecognizer>)>>(
      'DestroyOnlineRecognizer');
  late final _DestroyOnlineRecognizer = _DestroyOnlineRecognizerPtr.asFunction<
      void Function(ffi.Pointer<SherpaOnnxOnlineRecognizer>)>();

  /// Create an online stream for accepting wave samples.
  ///
  /// @param recognizer  A pointer returned by CreateOnlineRecognizer()
  /// @return Return a pointer to an OnlineStream. The user has to invoke
  /// DestroyOnlineStream() to free it to avoid memory leak.
  ffi.Pointer<SherpaOnnxOnlineStream> CreateOnlineStream(
    ffi.Pointer<SherpaOnnxOnlineRecognizer> recognizer,
  ) {
    return _CreateOnlineStream(
      recognizer,
    );
  }

  late final _CreateOnlineStreamPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SherpaOnnxOnlineStream> Function(
              ffi.Pointer<SherpaOnnxOnlineRecognizer>)>>('CreateOnlineStream');
  late final _CreateOnlineStream = _CreateOnlineStreamPtr.asFunction<
      ffi.Pointer<SherpaOnnxOnlineStream> Function(
          ffi.Pointer<SherpaOnnxOnlineRecognizer>)>();

  /// Create an online stream for accepting wave samples with the specified hot words.
  ///
  /// @param recognizer  A pointer returned by CreateOnlineRecognizer()
  /// @return Return a pointer to an OnlineStream. The user has to invoke
  /// DestroyOnlineStream() to free it to avoid memory leak.
  ffi.Pointer<SherpaOnnxOnlineStream> CreateOnlineStreamWithHotwords(
    ffi.Pointer<SherpaOnnxOnlineRecognizer> recognizer,
    ffi.Pointer<ffi.Char> hotwords,
  ) {
    return _CreateOnlineStreamWithHotwords(
      recognizer,
      hotwords,
    );
  }

  late final _CreateOnlineStreamWithHotwordsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SherpaOnnxOnlineStream> Function(
              ffi.Pointer<SherpaOnnxOnlineRecognizer>,
              ffi.Pointer<ffi.Char>)>>('CreateOnlineStreamWithHotwords');
  late final _CreateOnlineStreamWithHotwords =
      _CreateOnlineStreamWithHotwordsPtr.asFunction<
          ffi.Pointer<SherpaOnnxOnlineStream> Function(
              ffi.Pointer<SherpaOnnxOnlineRecognizer>,
              ffi.Pointer<ffi.Char>)>();

  /// Destroy an online stream.
  ///
  /// @param stream A pointer returned by CreateOnlineStream()
  void DestroyOnlineStream(
    ffi.Pointer<SherpaOnnxOnlineStream> stream,
  ) {
    return _DestroyOnlineStream(
      stream,
    );
  }

  late final _DestroyOnlineStreamPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<SherpaOnnxOnlineStream>)>>('DestroyOnlineStream');
  late final _DestroyOnlineStream = _DestroyOnlineStreamPtr.asFunction<
      void Function(ffi.Pointer<SherpaOnnxOnlineStream>)>();

  /// Accept input audio samples and compute the features.
  /// The user has to invoke DecodeOnlineStream() to run the neural network and
  /// decoding.
  ///
  /// @param stream  A pointer returned by CreateOnlineStream().
  /// @param sample_rate  Sample rate of the input samples. If it is different
  /// from config.feat_config.sample_rate, we will do
  /// resampling inside sherpa-onnx.
  /// @param samples A pointer to a 1-D array containing audio samples.
  /// The range of samples has to be normalized to [-1, 1].
  /// @param n  Number of elements in the samples array.
  void AcceptWaveform(
    ffi.Pointer<SherpaOnnxOnlineStream> stream,
    int sample_rate,
    ffi.Pointer<ffi.Float> samples,
    int n,
  ) {
    return _AcceptWaveform(
      stream,
      sample_rate,
      samples,
      n,
    );
  }

  late final _AcceptWaveformPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SherpaOnnxOnlineStream>, ffi.Int32,
              ffi.Pointer<ffi.Float>, ffi.Int32)>>('AcceptWaveform');
  late final _AcceptWaveform = _AcceptWaveformPtr.asFunction<
      void Function(ffi.Pointer<SherpaOnnxOnlineStream>, int,
          ffi.Pointer<ffi.Float>, int)>();

  /// Return 1 if there are enough number of feature frames for decoding.
  /// Return 0 otherwise.
  ///
  /// @param recognizer  A pointer returned by CreateOnlineRecognizer
  /// @param stream  A pointer returned by CreateOnlineStream
  int IsOnlineStreamReady(
    ffi.Pointer<SherpaOnnxOnlineRecognizer> recognizer,
    ffi.Pointer<SherpaOnnxOnlineStream> stream,
  ) {
    return _IsOnlineStreamReady(
      recognizer,
      stream,
    );
  }

  late final _IsOnlineStreamReadyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SherpaOnnxOnlineRecognizer>,
              ffi.Pointer<SherpaOnnxOnlineStream>)>>('IsOnlineStreamReady');
  late final _IsOnlineStreamReady = _IsOnlineStreamReadyPtr.asFunction<
      int Function(ffi.Pointer<SherpaOnnxOnlineRecognizer>,
          ffi.Pointer<SherpaOnnxOnlineStream>)>();

  /// Precondition for this function: IsOnlineStreamReady() MUST return 1.
  ///
  /// Usage example:
  ///
  /// while (IsOnlineStreamReady(recognizer, stream)) {
  /// DecodeOnlineStream(recognizer, stream);
  /// }
  void DecodeOnlineStream(
    ffi.Pointer<SherpaOnnxOnlineRecognizer> recognizer,
    ffi.Pointer<SherpaOnnxOnlineStream> stream,
  ) {
    return _DecodeOnlineStream(
      recognizer,
      stream,
    );
  }

  late final _DecodeOnlineStreamPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SherpaOnnxOnlineRecognizer>,
              ffi.Pointer<SherpaOnnxOnlineStream>)>>('DecodeOnlineStream');
  late final _DecodeOnlineStream = _DecodeOnlineStreamPtr.asFunction<
      void Function(ffi.Pointer<SherpaOnnxOnlineRecognizer>,
          ffi.Pointer<SherpaOnnxOnlineStream>)>();

  /// This function is similar to DecodeOnlineStream(). It decodes multiple
  /// OnlineStream in parallel.
  ///
  /// Caution: The caller has to ensure each OnlineStream is ready, i.e.,
  /// IsOnlineStreamReady() for that stream should return 1.
  ///
  /// @param recognizer  A pointer returned by CreateOnlineRecognizer()
  /// @param streams  A pointer array containing pointers returned by
  /// CreateOnlineRecognizer()
  /// @param n  Number of elements in the given streams array.
  void DecodeMultipleOnlineStreams(
    ffi.Pointer<SherpaOnnxOnlineRecognizer> recognizer,
    ffi.Pointer<ffi.Pointer<SherpaOnnxOnlineStream>> streams,
    int n,
  ) {
    return _DecodeMultipleOnlineStreams(
      recognizer,
      streams,
      n,
    );
  }

  late final _DecodeMultipleOnlineStreamsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<SherpaOnnxOnlineRecognizer>,
              ffi.Pointer<ffi.Pointer<SherpaOnnxOnlineStream>>,
              ffi.Int32)>>('DecodeMultipleOnlineStreams');
  late final _DecodeMultipleOnlineStreams =
      _DecodeMultipleOnlineStreamsPtr.asFunction<
          void Function(ffi.Pointer<SherpaOnnxOnlineRecognizer>,
              ffi.Pointer<ffi.Pointer<SherpaOnnxOnlineStream>>, int)>();

  /// Get the decoding results so far for an OnlineStream.
  ///
  /// @param recognizer A pointer returned by CreateOnlineRecognizer().
  /// @param stream A pointer returned by CreateOnlineStream().
  /// @return A pointer containing the result. The user has to invoke
  /// DestroyOnlineRecognizerResult() to free the returned pointer to
  /// avoid memory leak.
  ffi.Pointer<SherpaOnnxOnlineRecognizerResult> GetOnlineStreamResult(
    ffi.Pointer<SherpaOnnxOnlineRecognizer> recognizer,
    ffi.Pointer<SherpaOnnxOnlineStream> stream,
  ) {
    return _GetOnlineStreamResult(
      recognizer,
      stream,
    );
  }

  late final _GetOnlineStreamResultPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SherpaOnnxOnlineRecognizerResult> Function(
              ffi.Pointer<SherpaOnnxOnlineRecognizer>,
              ffi.Pointer<SherpaOnnxOnlineStream>)>>('GetOnlineStreamResult');
  late final _GetOnlineStreamResult = _GetOnlineStreamResultPtr.asFunction<
      ffi.Pointer<SherpaOnnxOnlineRecognizerResult> Function(
          ffi.Pointer<SherpaOnnxOnlineRecognizer>,
          ffi.Pointer<SherpaOnnxOnlineStream>)>();

  /// Destroy the pointer returned by GetOnlineStreamResult().
  ///
  /// @param r A pointer returned by GetOnlineStreamResult()
  void DestroyOnlineRecognizerResult(
    ffi.Pointer<SherpaOnnxOnlineRecognizerResult> r,
  ) {
    return _DestroyOnlineRecognizerResult(
      r,
    );
  }

  late final _DestroyOnlineRecognizerResultPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<SherpaOnnxOnlineRecognizerResult>)>>(
      'DestroyOnlineRecognizerResult');
  late final _DestroyOnlineRecognizerResult =
      _DestroyOnlineRecognizerResultPtr.asFunction<
          void Function(ffi.Pointer<SherpaOnnxOnlineRecognizerResult>)>();

  /// Reset an OnlineStream , which clears the neural network model state
  /// and the state for decoding.
  ///
  /// @param recognizer A pointer returned by CreateOnlineRecognizer().
  /// @param stream A pointer returned by CreateOnlineStream
  void Reset(
    ffi.Pointer<SherpaOnnxOnlineRecognizer> recognizer,
    ffi.Pointer<SherpaOnnxOnlineStream> stream,
  ) {
    return _Reset(
      recognizer,
      stream,
    );
  }

  late final _ResetPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SherpaOnnxOnlineRecognizer>,
              ffi.Pointer<SherpaOnnxOnlineStream>)>>('Reset');
  late final _Reset = _ResetPtr.asFunction<
      void Function(ffi.Pointer<SherpaOnnxOnlineRecognizer>,
          ffi.Pointer<SherpaOnnxOnlineStream>)>();

  /// Signal that no more audio samples would be available.
  /// After this call, you cannot call AcceptWaveform() any more.
  ///
  /// @param stream A pointer returned by CreateOnlineStream()
  void InputFinished(
    ffi.Pointer<SherpaOnnxOnlineStream> stream,
  ) {
    return _InputFinished(
      stream,
    );
  }

  late final _InputFinishedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<SherpaOnnxOnlineStream>)>>('InputFinished');
  late final _InputFinished = _InputFinishedPtr.asFunction<
      void Function(ffi.Pointer<SherpaOnnxOnlineStream>)>();

  /// Return 1 if an endpoint has been detected.
  ///
  /// @param recognizer A pointer returned by CreateOnlineRecognizer()
  /// @param stream A pointer returned by CreateOnlineStream()
  /// @return Return 1 if an endpoint is detected. Return 0 otherwise.
  int IsEndpoint(
    ffi.Pointer<SherpaOnnxOnlineRecognizer> recognizer,
    ffi.Pointer<SherpaOnnxOnlineStream> stream,
  ) {
    return _IsEndpoint(
      recognizer,
      stream,
    );
  }

  late final _IsEndpointPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<SherpaOnnxOnlineRecognizer>,
              ffi.Pointer<SherpaOnnxOnlineStream>)>>('IsEndpoint');
  late final _IsEndpoint = _IsEndpointPtr.asFunction<
      int Function(ffi.Pointer<SherpaOnnxOnlineRecognizer>,
          ffi.Pointer<SherpaOnnxOnlineStream>)>();

  /// Create a display object. Must be freed using DestroyDisplay to avoid
  /// memory leak.
  ffi.Pointer<SherpaOnnxDisplay> CreateDisplay(
    int max_word_per_line,
  ) {
    return _CreateDisplay(
      max_word_per_line,
    );
  }

  late final _CreateDisplayPtr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<SherpaOnnxDisplay> Function(ffi.Int32)>>(
      'CreateDisplay');
  late final _CreateDisplay = _CreateDisplayPtr.asFunction<
      ffi.Pointer<SherpaOnnxDisplay> Function(int)>();

  void DestroyDisplay(
    ffi.Pointer<SherpaOnnxDisplay> display,
  ) {
    return _DestroyDisplay(
      display,
    );
  }

  late final _DestroyDisplayPtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<SherpaOnnxDisplay>)>>(
      'DestroyDisplay');
  late final _DestroyDisplay = _DestroyDisplayPtr.asFunction<
      void Function(ffi.Pointer<SherpaOnnxDisplay>)>();

  /// Print the result.
  void SherpaOnnxPrint(
    ffi.Pointer<SherpaOnnxDisplay> display,
    int idx,
    ffi.Pointer<ffi.Char> s,
  ) {
    return _SherpaOnnxPrint(
      display,
      idx,
      s,
    );
  }

  late final _SherpaOnnxPrintPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SherpaOnnxDisplay>, ffi.Int32,
              ffi.Pointer<ffi.Char>)>>('SherpaOnnxPrint');
  late final _SherpaOnnxPrint = _SherpaOnnxPrintPtr.asFunction<
      void Function(
          ffi.Pointer<SherpaOnnxDisplay>, int, ffi.Pointer<ffi.Char>)>();

  /// @param config  Config for the recognizer.
  /// @return Return a pointer to the recognizer. The user has to invoke
  ffi.Pointer<SherpaOnnxOfflineRecognizer> CreateOfflineRecognizer(
    ffi.Pointer<SherpaOnnxOfflineRecognizerConfig> config,
  ) {
    return _CreateOfflineRecognizer(
      config,
    );
  }

  late final _CreateOfflineRecognizerPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<SherpaOnnxOfflineRecognizer> Function(
                  ffi.Pointer<SherpaOnnxOfflineRecognizerConfig>)>>(
      'CreateOfflineRecognizer');
  late final _CreateOfflineRecognizer = _CreateOfflineRecognizerPtr.asFunction<
      ffi.Pointer<SherpaOnnxOfflineRecognizer> Function(
          ffi.Pointer<SherpaOnnxOfflineRecognizerConfig>)>();

  /// Free a pointer returned by CreateOfflineRecognizer()
  ///
  /// @param p A pointer returned by CreateOfflineRecognizer()
  void DestroyOfflineRecognizer(
    ffi.Pointer<SherpaOnnxOfflineRecognizer> recognizer,
  ) {
    return _DestroyOfflineRecognizer(
      recognizer,
    );
  }

  late final _DestroyOfflineRecognizerPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<SherpaOnnxOfflineRecognizer>)>>(
      'DestroyOfflineRecognizer');
  late final _DestroyOfflineRecognizer = _DestroyOfflineRecognizerPtr
      .asFunction<void Function(ffi.Pointer<SherpaOnnxOfflineRecognizer>)>();

  /// Create an offline stream for accepting wave samples.
  ///
  /// @param recognizer  A pointer returned by CreateOfflineRecognizer()
  /// @return Return a pointer to an OfflineStream. The user has to invoke
  /// DestroyOfflineStream() to free it to avoid memory leak.
  ffi.Pointer<SherpaOnnxOfflineStream> CreateOfflineStream(
    ffi.Pointer<SherpaOnnxOfflineRecognizer> recognizer,
  ) {
    return _CreateOfflineStream(
      recognizer,
    );
  }

  late final _CreateOfflineStreamPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<SherpaOnnxOfflineStream> Function(
                  ffi.Pointer<SherpaOnnxOfflineRecognizer>)>>(
      'CreateOfflineStream');
  late final _CreateOfflineStream = _CreateOfflineStreamPtr.asFunction<
      ffi.Pointer<SherpaOnnxOfflineStream> Function(
          ffi.Pointer<SherpaOnnxOfflineRecognizer>)>();

  /// Destroy an offline stream.
  ///
  /// @param stream A pointer returned by CreateOfflineStream()
  void DestroyOfflineStream(
    ffi.Pointer<SherpaOnnxOfflineStream> stream,
  ) {
    return _DestroyOfflineStream(
      stream,
    );
  }

  late final _DestroyOfflineStreamPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<SherpaOnnxOfflineStream>)>>('DestroyOfflineStream');
  late final _DestroyOfflineStream = _DestroyOfflineStreamPtr.asFunction<
      void Function(ffi.Pointer<SherpaOnnxOfflineStream>)>();

  /// Accept input audio samples and compute the features.
  /// The user has to invoke DecodeOfflineStream() to run the neural network and
  /// decoding.
  ///
  /// @param stream  A pointer returned by CreateOfflineStream().
  /// @param sample_rate  Sample rate of the input samples. If it is different
  /// from config.feat_config.sample_rate, we will do
  /// resampling inside sherpa-onnx.
  /// @param samples A pointer to a 1-D array containing audio samples.
  /// The range of samples has to be normalized to [-1, 1].
  /// @param n  Number of elements in the samples array.
  ///
  /// @caution: For each offline stream, please invoke this function only once!
  void AcceptWaveformOffline(
    ffi.Pointer<SherpaOnnxOfflineStream> stream,
    int sample_rate,
    ffi.Pointer<ffi.Float> samples,
    int n,
  ) {
    return _AcceptWaveformOffline(
      stream,
      sample_rate,
      samples,
      n,
    );
  }

  late final _AcceptWaveformOfflinePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SherpaOnnxOfflineStream>, ffi.Int32,
              ffi.Pointer<ffi.Float>, ffi.Int32)>>('AcceptWaveformOffline');
  late final _AcceptWaveformOffline = _AcceptWaveformOfflinePtr.asFunction<
      void Function(ffi.Pointer<SherpaOnnxOfflineStream>, int,
          ffi.Pointer<ffi.Float>, int)>();

  /// Decode an offline stream.
  ///
  /// We assume you have invoked AcceptWaveformOffline() for the given stream
  /// before calling this function.
  ///
  /// @param recognizer A pointer returned by CreateOfflineRecognizer().
  /// @param stream A pointer returned by CreateOfflineStream()
  void DecodeOfflineStream(
    ffi.Pointer<SherpaOnnxOfflineRecognizer> recognizer,
    ffi.Pointer<SherpaOnnxOfflineStream> stream,
  ) {
    return _DecodeOfflineStream(
      recognizer,
      stream,
    );
  }

  late final _DecodeOfflineStreamPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SherpaOnnxOfflineRecognizer>,
              ffi.Pointer<SherpaOnnxOfflineStream>)>>('DecodeOfflineStream');
  late final _DecodeOfflineStream = _DecodeOfflineStreamPtr.asFunction<
      void Function(ffi.Pointer<SherpaOnnxOfflineRecognizer>,
          ffi.Pointer<SherpaOnnxOfflineStream>)>();

  /// Decode a list offline streams in parallel.
  ///
  /// We assume you have invoked AcceptWaveformOffline() for each stream
  /// before calling this function.
  ///
  /// @param recognizer A pointer returned by CreateOfflineRecognizer().
  /// @param streams A pointer pointer array containing pointers returned
  /// by CreateOfflineStream().
  /// @param n Number of entries in the given streams.
  void DecodeMultipleOfflineStreams(
    ffi.Pointer<SherpaOnnxOfflineRecognizer> recognizer,
    ffi.Pointer<ffi.Pointer<SherpaOnnxOfflineStream>> streams,
    int n,
  ) {
    return _DecodeMultipleOfflineStreams(
      recognizer,
      streams,
      n,
    );
  }

  late final _DecodeMultipleOfflineStreamsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<SherpaOnnxOfflineRecognizer>,
              ffi.Pointer<ffi.Pointer<SherpaOnnxOfflineStream>>,
              ffi.Int32)>>('DecodeMultipleOfflineStreams');
  late final _DecodeMultipleOfflineStreams =
      _DecodeMultipleOfflineStreamsPtr.asFunction<
          void Function(ffi.Pointer<SherpaOnnxOfflineRecognizer>,
              ffi.Pointer<ffi.Pointer<SherpaOnnxOfflineStream>>, int)>();

  /// Get the result of the offline stream.
  ///
  /// We assume you have called DecodeOfflineStream() or
  /// DecodeMultipleOfflineStreams() with the given stream before calling
  /// this function.
  ///
  /// @param stream A pointer returned by CreateOfflineStream().
  /// @return Return a pointer to the result. The user has to invoke
  /// DestroyOnlineRecognizerResult() to free the returned pointer to
  /// avoid memory leak.
  ffi.Pointer<SherpaOnnxOfflineRecognizerResult> GetOfflineStreamResult(
    ffi.Pointer<SherpaOnnxOfflineStream> stream,
  ) {
    return _GetOfflineStreamResult(
      stream,
    );
  }

  late final _GetOfflineStreamResultPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SherpaOnnxOfflineRecognizerResult> Function(
              ffi.Pointer<SherpaOnnxOfflineStream>)>>('GetOfflineStreamResult');
  late final _GetOfflineStreamResult = _GetOfflineStreamResultPtr.asFunction<
      ffi.Pointer<SherpaOnnxOfflineRecognizerResult> Function(
          ffi.Pointer<SherpaOnnxOfflineStream>)>();

  /// Destroy the pointer returned by GetOfflineStreamResult().
  ///
  /// @param r A pointer returned by GetOfflineStreamResult()
  void DestroyOfflineRecognizerResult(
    ffi.Pointer<SherpaOnnxOfflineRecognizerResult> r,
  ) {
    return _DestroyOfflineRecognizerResult(
      r,
    );
  }

  late final _DestroyOfflineRecognizerResultPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<SherpaOnnxOfflineRecognizerResult>)>>(
      'DestroyOfflineRecognizerResult');
  late final _DestroyOfflineRecognizerResult =
      _DestroyOfflineRecognizerResultPtr.asFunction<
          void Function(ffi.Pointer<SherpaOnnxOfflineRecognizerResult>)>();

  ffi.Pointer<SherpaOnnxCircularBuffer> SherpaOnnxCreateCircularBuffer(
    int capacity,
  ) {
    return _SherpaOnnxCreateCircularBuffer(
      capacity,
    );
  }

  late final _SherpaOnnxCreateCircularBufferPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SherpaOnnxCircularBuffer> Function(
              ffi.Int32)>>('SherpaOnnxCreateCircularBuffer');
  late final _SherpaOnnxCreateCircularBuffer =
      _SherpaOnnxCreateCircularBufferPtr.asFunction<
          ffi.Pointer<SherpaOnnxCircularBuffer> Function(int)>();

  void SherpaOnnxDestroyCircularBuffer(
    ffi.Pointer<SherpaOnnxCircularBuffer> buffer,
  ) {
    return _SherpaOnnxDestroyCircularBuffer(
      buffer,
    );
  }

  late final _SherpaOnnxDestroyCircularBufferPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<SherpaOnnxCircularBuffer>)>>(
      'SherpaOnnxDestroyCircularBuffer');
  late final _SherpaOnnxDestroyCircularBuffer =
      _SherpaOnnxDestroyCircularBufferPtr.asFunction<
          void Function(ffi.Pointer<SherpaOnnxCircularBuffer>)>();

  void SherpaOnnxCircularBufferPush(
    ffi.Pointer<SherpaOnnxCircularBuffer> buffer,
    ffi.Pointer<ffi.Float> p,
    int n,
  ) {
    return _SherpaOnnxCircularBufferPush(
      buffer,
      p,
      n,
    );
  }

  late final _SherpaOnnxCircularBufferPushPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<SherpaOnnxCircularBuffer>,
              ffi.Pointer<ffi.Float>,
              ffi.Int32)>>('SherpaOnnxCircularBufferPush');
  late final _SherpaOnnxCircularBufferPush =
      _SherpaOnnxCircularBufferPushPtr.asFunction<
          void Function(ffi.Pointer<SherpaOnnxCircularBuffer>,
              ffi.Pointer<ffi.Float>, int)>();

  ffi.Pointer<ffi.Float> SherpaOnnxCircularBufferGet(
    ffi.Pointer<SherpaOnnxCircularBuffer> buffer,
    int start_index,
    int n,
  ) {
    return _SherpaOnnxCircularBufferGet(
      buffer,
      start_index,
      n,
    );
  }

  late final _SherpaOnnxCircularBufferGetPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Float> Function(ffi.Pointer<SherpaOnnxCircularBuffer>,
              ffi.Int32, ffi.Int32)>>('SherpaOnnxCircularBufferGet');
  late final _SherpaOnnxCircularBufferGet =
      _SherpaOnnxCircularBufferGetPtr.asFunction<
          ffi.Pointer<ffi.Float> Function(
              ffi.Pointer<SherpaOnnxCircularBuffer>, int, int)>();

  void SherpaOnnxCircularBufferFree(
    ffi.Pointer<ffi.Float> p,
  ) {
    return _SherpaOnnxCircularBufferFree(
      p,
    );
  }

  late final _SherpaOnnxCircularBufferFreePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Float>)>>(
          'SherpaOnnxCircularBufferFree');
  late final _SherpaOnnxCircularBufferFree = _SherpaOnnxCircularBufferFreePtr
      .asFunction<void Function(ffi.Pointer<ffi.Float>)>();

  void SherpaOnnxCircularBufferPop(
    ffi.Pointer<SherpaOnnxCircularBuffer> buffer,
    int n,
  ) {
    return _SherpaOnnxCircularBufferPop(
      buffer,
      n,
    );
  }

  late final _SherpaOnnxCircularBufferPopPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SherpaOnnxCircularBuffer>,
              ffi.Int32)>>('SherpaOnnxCircularBufferPop');
  late final _SherpaOnnxCircularBufferPop = _SherpaOnnxCircularBufferPopPtr
      .asFunction<void Function(ffi.Pointer<SherpaOnnxCircularBuffer>, int)>();

  int SherpaOnnxCircularBufferSize(
    ffi.Pointer<SherpaOnnxCircularBuffer> buffer,
  ) {
    return _SherpaOnnxCircularBufferSize(
      buffer,
    );
  }

  late final _SherpaOnnxCircularBufferSizePtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(ffi.Pointer<SherpaOnnxCircularBuffer>)>>(
      'SherpaOnnxCircularBufferSize');
  late final _SherpaOnnxCircularBufferSize = _SherpaOnnxCircularBufferSizePtr
      .asFunction<int Function(ffi.Pointer<SherpaOnnxCircularBuffer>)>();

  void SherpaOnnxCircularBufferReset(
    ffi.Pointer<SherpaOnnxCircularBuffer> buffer,
  ) {
    return _SherpaOnnxCircularBufferReset(
      buffer,
    );
  }

  late final _SherpaOnnxCircularBufferResetPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<SherpaOnnxCircularBuffer>)>>(
      'SherpaOnnxCircularBufferReset');
  late final _SherpaOnnxCircularBufferReset = _SherpaOnnxCircularBufferResetPtr
      .asFunction<void Function(ffi.Pointer<SherpaOnnxCircularBuffer>)>();

  ffi.Pointer<SherpaOnnxVoiceActivityDetector>
      SherpaOnnxCreateVoiceActivityDetector(
    ffi.Pointer<SherpaOnnxVadModelConfig> config,
    double buffer_size_in_seconds,
  ) {
    return _SherpaOnnxCreateVoiceActivityDetector(
      config,
      buffer_size_in_seconds,
    );
  }

  late final _SherpaOnnxCreateVoiceActivityDetectorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SherpaOnnxVoiceActivityDetector> Function(
              ffi.Pointer<SherpaOnnxVadModelConfig>,
              ffi.Float)>>('SherpaOnnxCreateVoiceActivityDetector');
  late final _SherpaOnnxCreateVoiceActivityDetector =
      _SherpaOnnxCreateVoiceActivityDetectorPtr.asFunction<
          ffi.Pointer<SherpaOnnxVoiceActivityDetector> Function(
              ffi.Pointer<SherpaOnnxVadModelConfig>, double)>();

  void SherpaOnnxDestroyVoiceActivityDetector(
    ffi.Pointer<SherpaOnnxVoiceActivityDetector> p,
  ) {
    return _SherpaOnnxDestroyVoiceActivityDetector(
      p,
    );
  }

  late final _SherpaOnnxDestroyVoiceActivityDetectorPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<SherpaOnnxVoiceActivityDetector>)>>(
      'SherpaOnnxDestroyVoiceActivityDetector');
  late final _SherpaOnnxDestroyVoiceActivityDetector =
      _SherpaOnnxDestroyVoiceActivityDetectorPtr.asFunction<
          void Function(ffi.Pointer<SherpaOnnxVoiceActivityDetector>)>();

  void SherpaOnnxVoiceActivityDetectorAcceptWaveform(
    ffi.Pointer<SherpaOnnxVoiceActivityDetector> p,
    ffi.Pointer<ffi.Float> samples,
    int n,
  ) {
    return _SherpaOnnxVoiceActivityDetectorAcceptWaveform(
      p,
      samples,
      n,
    );
  }

  late final _SherpaOnnxVoiceActivityDetectorAcceptWaveformPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<SherpaOnnxVoiceActivityDetector>,
              ffi.Pointer<ffi.Float>,
              ffi.Int32)>>('SherpaOnnxVoiceActivityDetectorAcceptWaveform');
  late final _SherpaOnnxVoiceActivityDetectorAcceptWaveform =
      _SherpaOnnxVoiceActivityDetectorAcceptWaveformPtr.asFunction<
          void Function(ffi.Pointer<SherpaOnnxVoiceActivityDetector>,
              ffi.Pointer<ffi.Float>, int)>();

  int SherpaOnnxVoiceActivityDetectorEmpty(
    ffi.Pointer<SherpaOnnxVoiceActivityDetector> p,
  ) {
    return _SherpaOnnxVoiceActivityDetectorEmpty(
      p,
    );
  }

  late final _SherpaOnnxVoiceActivityDetectorEmptyPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
                  ffi.Pointer<SherpaOnnxVoiceActivityDetector>)>>(
      'SherpaOnnxVoiceActivityDetectorEmpty');
  late final _SherpaOnnxVoiceActivityDetectorEmpty =
      _SherpaOnnxVoiceActivityDetectorEmptyPtr.asFunction<
          int Function(ffi.Pointer<SherpaOnnxVoiceActivityDetector>)>();

  void SherpaOnnxVoiceActivityDetectorPop(
    ffi.Pointer<SherpaOnnxVoiceActivityDetector> p,
  ) {
    return _SherpaOnnxVoiceActivityDetectorPop(
      p,
    );
  }

  late final _SherpaOnnxVoiceActivityDetectorPopPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<SherpaOnnxVoiceActivityDetector>)>>(
      'SherpaOnnxVoiceActivityDetectorPop');
  late final _SherpaOnnxVoiceActivityDetectorPop =
      _SherpaOnnxVoiceActivityDetectorPopPtr.asFunction<
          void Function(ffi.Pointer<SherpaOnnxVoiceActivityDetector>)>();

  ffi.Pointer<SherpaOnnxSpeechSegment> SherpaOnnxVoiceActivityDetectorFront(
    ffi.Pointer<SherpaOnnxVoiceActivityDetector> p,
  ) {
    return _SherpaOnnxVoiceActivityDetectorFront(
      p,
    );
  }

  late final _SherpaOnnxVoiceActivityDetectorFrontPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<SherpaOnnxSpeechSegment> Function(
                  ffi.Pointer<SherpaOnnxVoiceActivityDetector>)>>(
      'SherpaOnnxVoiceActivityDetectorFront');
  late final _SherpaOnnxVoiceActivityDetectorFront =
      _SherpaOnnxVoiceActivityDetectorFrontPtr.asFunction<
          ffi.Pointer<SherpaOnnxSpeechSegment> Function(
              ffi.Pointer<SherpaOnnxVoiceActivityDetector>)>();

  void SherpaOnnxDestroySpeechSegment(
    ffi.Pointer<SherpaOnnxSpeechSegment> p,
  ) {
    return _SherpaOnnxDestroySpeechSegment(
      p,
    );
  }

  late final _SherpaOnnxDestroySpeechSegmentPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<SherpaOnnxSpeechSegment>)>>(
      'SherpaOnnxDestroySpeechSegment');
  late final _SherpaOnnxDestroySpeechSegment =
      _SherpaOnnxDestroySpeechSegmentPtr.asFunction<
          void Function(ffi.Pointer<SherpaOnnxSpeechSegment>)>();

  void SherpaOnnxVoiceActivityDetectorReset(
    ffi.Pointer<SherpaOnnxVoiceActivityDetector> p,
  ) {
    return _SherpaOnnxVoiceActivityDetectorReset(
      p,
    );
  }

  late final _SherpaOnnxVoiceActivityDetectorResetPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<SherpaOnnxVoiceActivityDetector>)>>(
      'SherpaOnnxVoiceActivityDetectorReset');
  late final _SherpaOnnxVoiceActivityDetectorReset =
      _SherpaOnnxVoiceActivityDetectorResetPtr.asFunction<
          void Function(ffi.Pointer<SherpaOnnxVoiceActivityDetector>)>();
}

class __mbstate_t extends ffi.Union {
  @ffi.Array.multi([128])
  external ffi.Array<ffi.Char> __mbstate8;

  @ffi.LongLong()
  external int _mbstateL;
}

class __darwin_pthread_handler_rec extends ffi.Struct {
  external ffi
      .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      __routine;

  external ffi.Pointer<ffi.Void> __arg;

  external ffi.Pointer<__darwin_pthread_handler_rec> __next;
}

class _opaque_pthread_attr_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([56])
  external ffi.Array<ffi.Char> __opaque;
}

class _opaque_pthread_cond_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([40])
  external ffi.Array<ffi.Char> __opaque;
}

class _opaque_pthread_condattr_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.Char> __opaque;
}

class _opaque_pthread_mutex_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([56])
  external ffi.Array<ffi.Char> __opaque;
}

class _opaque_pthread_mutexattr_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.Char> __opaque;
}

class _opaque_pthread_once_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.Char> __opaque;
}

class _opaque_pthread_rwlock_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([192])
  external ffi.Array<ffi.Char> __opaque;
}

class _opaque_pthread_rwlockattr_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([16])
  external ffi.Array<ffi.Char> __opaque;
}

class _opaque_pthread_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  external ffi.Pointer<__darwin_pthread_handler_rec> __cleanup_stack;

  @ffi.Array.multi([8176])
  external ffi.Array<ffi.Char> __opaque;
}

/// Please refer to
/// https://k2-fsa.github.io/sherpa/onnx/pretrained_models/index.html
/// to download pre-trained models. That is, you can find encoder-xxx.onnx
/// decoder-xxx.onnx, joiner-xxx.onnx, and tokens.txt for this struct
/// from there.
class SherpaOnnxOnlineTransducerModelConfig extends ffi.Struct {
  external ffi.Pointer<ffi.Char> encoder;

  external ffi.Pointer<ffi.Char> decoder;

  external ffi.Pointer<ffi.Char> joiner;
}

class SherpaOnnxOnlineParaformerModelConfig extends ffi.Struct {
  external ffi.Pointer<ffi.Char> encoder;

  external ffi.Pointer<ffi.Char> decoder;
}

class SherpaOnnxModelConfig extends ffi.Struct {
  external SherpaOnnxOnlineTransducerModelConfig transducer;

  external SherpaOnnxOnlineParaformerModelConfig paraformer;

  external ffi.Pointer<ffi.Char> tokens;

  @ffi.Int32()
  external int num_threads;

  external ffi.Pointer<ffi.Char> provider;

  @ffi.Int32()
  external int debug;

  external ffi.Pointer<ffi.Char> model_type;
}

/// It expects 16 kHz 16-bit single channel wave format.
class SherpaOnnxFeatureConfig extends ffi.Struct {
  /// Sample rate of the input data. MUST match the one expected
  /// by the model. For instance, it should be 16000 for models provided
  /// by us.
  @ffi.Int32()
  external int sample_rate;

  /// Feature dimension of the model.
  /// For instance, it should be 80 for models provided by us.
  @ffi.Int32()
  external int feature_dim;
}

class SherpaOnnxOnlineRecognizerConfig extends ffi.Struct {
  external SherpaOnnxFeatureConfig feat_config;

  external SherpaOnnxOnlineModelConfig model_config;

  /// Possible values are: greedy_search, modified_beam_search
  external ffi.Pointer<ffi.Char> decoding_method;

  /// Used only when decoding_method is modified_beam_search
  /// Example value: 4
  @ffi.Int32()
  external int max_active_paths;

  /// 0 to disable endpoint detection.
  /// A non-zero value to enable endpoint detection.
  @ffi.Int32()
  external int enable_endpoint;

  /// An endpoint is detected if trailing silence in seconds is larger than
  /// this value even if nothing has been decoded.
  /// Used only when enable_endpoint is not 0.
  @ffi.Float()
  external double rule1_min_trailing_silence;

  /// An endpoint is detected if trailing silence in seconds is larger than
  /// this value after something that is not blank has been decoded.
  /// Used only when enable_endpoint is not 0.
  @ffi.Float()
  external double rule2_min_trailing_silence;

  /// An endpoint is detected if the utterance in seconds is larger than
  /// this value.
  /// Used only when enable_endpoint is not 0.
  @ffi.Float()
  external double rule3_min_utterance_length;

  /// Path to the hotwords.
  external ffi.Pointer<ffi.Char> hotwords_file;

  /// Bonus score for each token in hotwords.
  @ffi.Float()
  external double hotwords_score;
}

typedef SherpaOnnxOnlineModelConfig = SherpaOnnxModelConfig;

class SherpaOnnxOnlineRecognizerResult extends ffi.Struct {
  external ffi.Pointer<ffi.Char> text;

  external ffi.Pointer<ffi.Char> tokens;

  external ffi.Pointer<ffi.Pointer<ffi.Char>> tokens_arr;

  external ffi.Pointer<ffi.Float> timestamps;

  @ffi.Int32()
  external int count;

  /// Return a json string.
  ///
  /// The returned string contains:
  /// {
  /// "text": "The recognition result",
  /// "tokens": [x, x, x],
  /// "timestamps": [x, x, x],
  /// "segment": x,
  /// "start_time": x,
  /// "is_final": true|false
  /// }
  external ffi.Pointer<ffi.Char> json;
}

class SherpaOnnxOnlineRecognizer extends ffi.Opaque {}

class SherpaOnnxOnlineStream extends ffi.Opaque {}

class SherpaOnnxDisplay extends ffi.Opaque {}

/// Please refer to
/// https://k2-fsa.github.io/sherpa/onnx/pretrained_models/index.html
/// to download pre-trained models. That is, you can find encoder-xxx.onnx
/// decoder-xxx.onnx, and joiner-xxx.onnx for this struct
/// from there.
class SherpaOnnxOfflineTransducerModelConfig extends ffi.Struct {
  external ffi.Pointer<ffi.Char> encoder;

  external ffi.Pointer<ffi.Char> decoder;

  external ffi.Pointer<ffi.Char> joiner;
}

class SherpaOnnxOfflineParaformerModelConfig extends ffi.Struct {
  external ffi.Pointer<ffi.Char> model;
}

class SherpaOnnxOfflineNemoEncDecCtcModelConfig extends ffi.Struct {
  external ffi.Pointer<ffi.Char> model;
}

class SherpaOnnxOfflineWhisperModelConfig extends ffi.Struct {
  external ffi.Pointer<ffi.Char> encoder;

  external ffi.Pointer<ffi.Char> decoder;
}

class SherpaOnnxOfflineTdnnModelConfig extends ffi.Struct {
  external ffi.Pointer<ffi.Char> model;
}

class SherpaOnnxOfflineLMConfig extends ffi.Struct {
  external ffi.Pointer<ffi.Char> model;

  @ffi.Float()
  external double scale;
}

class SherpaOnnxOfflineModelConfig extends ffi.Struct {
  external SherpaOnnxOfflineTransducerModelConfig transducer;

  external SherpaOnnxOfflineParaformerModelConfig paraformer;

  external SherpaOnnxOfflineNemoEncDecCtcModelConfig nemo_ctc;

  external SherpaOnnxOfflineWhisperModelConfig whisper;

  external SherpaOnnxOfflineTdnnModelConfig tdnn;

  external ffi.Pointer<ffi.Char> tokens;

  @ffi.Int32()
  external int num_threads;

  @ffi.Int32()
  external int debug;

  external ffi.Pointer<ffi.Char> provider;

  external ffi.Pointer<ffi.Char> model_type;
}

class SherpaOnnxOfflineRecognizerConfig extends ffi.Struct {
  external SherpaOnnxFeatureConfig feat_config;

  external SherpaOnnxOfflineModelConfig model_config;

  external SherpaOnnxOfflineLMConfig lm_config;

  external ffi.Pointer<ffi.Char> decoding_method;

  @ffi.Int32()
  external int max_active_paths;

  /// Path to the hotwords.
  external ffi.Pointer<ffi.Char> hotwords_file;

  /// Bonus score for each token in hotwords.
  @ffi.Float()
  external double hotwords_score;
}

class SherpaOnnxOfflineRecognizer extends ffi.Opaque {}

class SherpaOnnxOfflineStream extends ffi.Opaque {}

class SherpaOnnxOfflineRecognizerResult extends ffi.Struct {
  external ffi.Pointer<ffi.Char> text;

  external ffi.Pointer<ffi.Float> timestamps;

  @ffi.Int32()
  external int count;
}

class SherpaOnnxSileroVadModelConfig extends ffi.Struct {
  external ffi.Pointer<ffi.Char> model;

  @ffi.Float()
  external double threshold;

  @ffi.Float()
  external double min_silence_duration;

  @ffi.Float()
  external double min_speech_duration;

  @ffi.Int()
  external int window_size;
}

class SherpaOnnxVadModelConfig extends ffi.Struct {
  external SherpaOnnxSileroVadModelConfig silero_vad;

  @ffi.Int32()
  external int sample_rate;

  @ffi.Int32()
  external int num_threads;

  external ffi.Pointer<ffi.Char> provider;

  @ffi.Int32()
  external int debug;
}

class SherpaOnnxCircularBuffer extends ffi.Opaque {}

class SherpaOnnxSpeechSegment extends ffi.Struct {
  @ffi.Int32()
  external int start;

  external ffi.Pointer<ffi.Float> samples;

  @ffi.Int32()
  external int n;
}

class SherpaOnnxVoiceActivityDetector extends ffi.Opaque {}

const int __WORDSIZE = 64;

const int __DARWIN_ONLY_64_BIT_INO_T = 1;

const int __DARWIN_ONLY_UNIX_CONFORMANCE = 1;

const int __DARWIN_ONLY_VERS_1050 = 1;

const int __DARWIN_UNIX03 = 1;

const int __DARWIN_64_BIT_INO_T = 1;

const int __DARWIN_VERS_1050 = 1;

const int __DARWIN_NON_CANCELABLE = 0;

const String __DARWIN_SUF_EXTSN = '\$DARWIN_EXTSN';

const int __DARWIN_C_ANSI = 4096;

const int __DARWIN_C_FULL = 900000;

const int __DARWIN_C_LEVEL = 900000;

const int __STDC_WANT_LIB_EXT1__ = 1;

const int __DARWIN_NO_LONG_LONG = 0;

const int _DARWIN_FEATURE_64_BIT_INODE = 1;

const int _DARWIN_FEATURE_ONLY_64_BIT_INODE = 1;

const int _DARWIN_FEATURE_ONLY_VERS_1050 = 1;

const int _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE = 1;

const int _DARWIN_FEATURE_UNIX_CONFORMANCE = 3;

const int __has_ptrcheck = 0;

const int __DARWIN_NULL = 0;

const int __PTHREAD_SIZE__ = 8176;

const int __PTHREAD_ATTR_SIZE__ = 56;

const int __PTHREAD_MUTEXATTR_SIZE__ = 8;

const int __PTHREAD_MUTEX_SIZE__ = 56;

const int __PTHREAD_CONDATTR_SIZE__ = 8;

const int __PTHREAD_COND_SIZE__ = 40;

const int __PTHREAD_ONCE_SIZE__ = 8;

const int __PTHREAD_RWLOCK_SIZE__ = 192;

const int __PTHREAD_RWLOCKATTR_SIZE__ = 16;

const int USER_ADDR_NULL = 0;

const int INT8_MAX = 127;

const int INT16_MAX = 32767;

const int INT32_MAX = 2147483647;

const int INT64_MAX = 9223372036854775807;

const int INT8_MIN = -128;

const int INT16_MIN = -32768;

const int INT32_MIN = -2147483648;

const int INT64_MIN = -9223372036854775808;

const int UINT8_MAX = 255;

const int UINT16_MAX = 65535;

const int UINT32_MAX = 4294967295;

const int UINT64_MAX = -1;

const int INT_LEAST8_MIN = -128;

const int INT_LEAST16_MIN = -32768;

const int INT_LEAST32_MIN = -2147483648;

const int INT_LEAST64_MIN = -9223372036854775808;

const int INT_LEAST8_MAX = 127;

const int INT_LEAST16_MAX = 32767;

const int INT_LEAST32_MAX = 2147483647;

const int INT_LEAST64_MAX = 9223372036854775807;

const int UINT_LEAST8_MAX = 255;

const int UINT_LEAST16_MAX = 65535;

const int UINT_LEAST32_MAX = 4294967295;

const int UINT_LEAST64_MAX = -1;

const int INT_FAST8_MIN = -128;

const int INT_FAST16_MIN = -32768;

const int INT_FAST32_MIN = -2147483648;

const int INT_FAST64_MIN = -9223372036854775808;

const int INT_FAST8_MAX = 127;

const int INT_FAST16_MAX = 32767;

const int INT_FAST32_MAX = 2147483647;

const int INT_FAST64_MAX = 9223372036854775807;

const int UINT_FAST8_MAX = 255;

const int UINT_FAST16_MAX = 65535;

const int UINT_FAST32_MAX = 4294967295;

const int UINT_FAST64_MAX = -1;

const int INTPTR_MAX = 9223372036854775807;

const int INTPTR_MIN = -9223372036854775808;

const int UINTPTR_MAX = -1;

const int INTMAX_MAX = 9223372036854775807;

const int UINTMAX_MAX = -1;

const int INTMAX_MIN = -9223372036854775808;

const int PTRDIFF_MIN = -9223372036854775808;

const int PTRDIFF_MAX = 9223372036854775807;

const int SIZE_MAX = -1;

const int RSIZE_MAX = 9223372036854775807;

const int WCHAR_MAX = 2147483647;

const int WCHAR_MIN = -2147483648;

const int WINT_MIN = -2147483648;

const int WINT_MAX = 2147483647;

const int SIG_ATOMIC_MIN = -2147483648;

const int SIG_ATOMIC_MAX = 2147483647;
